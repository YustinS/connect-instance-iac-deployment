import pulumi
import pulumi_aws as aws
import pulumi_std as std

def single_or_none(elements):
    if len(elements) != 1:
        raise Exception("single_or_none expected input list to have a single element")
    return elements[0]


config = pulumi.Config()
# String that will be prepended to names for consistency. Contents only [a-zA-Z0-9-]
name_prefix = config.require("namePrefix")
# What Identity Management that Connect will use. Valid values are 'SAML', 'CONNECT_MANAGED', or 'EXISTING_DIRECTORY'. 'SAML' or 'EXISTING_DIRECTORY' will require more resources to be created/managed externally to this module. See https://docs.aws.amazon.com/connect/latest/adminguide/connect-identity-management.html for more information
connect_identity_management_type = config.require("connectIdentityManagementType")
# The environment this is running against, such as 'dev', 'test' etc. Will the postfixed to names for consistency.
environment = config.require("environment")
# If desired an existing S3 Bucket can be used to store content generated by Connect. If not provided, a new S3 Bucket will be created. The prefix for the bucket will be 'connect/{instance_name}/{content_prefix}'
existing_s3_bucket_name = config.get_object("existingS3BucketName")
if existing_s3_bucket_name is None:
    existing_s3_bucket_name = None
# If variable `connect_identity_management_type` is set to 'EXISTING_DIRECTORY', then the ID of the Existing Directory Connect will be joined to
connect_existing_directory_id = config.get("connectExistingDirectoryId")
if connect_existing_directory_id is None:
    connect_existing_directory_id = "N/A"
# KMS ARN for a key used to encrypt created CloudWatch Log Group(s). Ensure KMS has the appropriate Key Policy
log_encryption_cmk = config.get_object("logEncryptionCmk")
if log_encryption_cmk is None:
    log_encryption_cmk = None
# KMS ARN for a key used to encrypt created S3 Content created from Connect. Ensure KMS has the appropriate key policy, and that Connect or its Service Role has appropriate permissions to encrypt content
s3_encryption_cmk = config.get_object("s3EncryptionCmk")
if s3_encryption_cmk is None:
    s3_encryption_cmk = None
# The length of time to maintain logs for
log_retention_days = config.get_float("logRetentionDays")
if log_retention_days is None:
    log_retention_days = 90
# Will the created Connect Instance be able to receive inbound calls
inbound_calls_enabled = config.get_bool("inboundCallsEnabled")
if inbound_calls_enabled is None:
    inbound_calls_enabled = True
# Will the created Connect Instance be able to make outbound calls
outbound_calls_enabled = config.get_bool("outboundCallsEnabled")
if outbound_calls_enabled is None:
    outbound_calls_enabled = True
# Will Early Media be heard by the Agent when a call is answered. Recommended left on unless specific reasons are identified
early_media_enabled = config.get_bool("earlyMediaEnabled")
if early_media_enabled is None:
    early_media_enabled = True
# Will Connect attempt to use the best avilaible voice. Recommended left on unless specific reasons are identified
auto_resolve_best_voices_enabled = config.get_bool("autoResolveBestVoicesEnabled")
if auto_resolve_best_voices_enabled is None:
    auto_resolve_best_voices_enabled = True
# Will Connect log Contact Flow activity to CloudWatch logs (if the appropriate setting is enabled in the Contact Flow). Recommended left on to assist with trouble shooting, and disabling logging in specific flows as required
contact_flow_logs_enabled = config.get_bool("contactFlowLogsEnabled")
if contact_flow_logs_enabled is None:
    contact_flow_logs_enabled = True
# Will Connect use Amazon Connect Contact Lens to analyse calls. For proper usage ensure instance storage configuration has been configured, and the appropriate flow blocks configure the usage inside of a contact flow
contact_lens_enabled = config.get_bool("contactLensEnabled")
if contact_lens_enabled is None:
    contact_lens_enabled = True
# Will Multiparty conferencing be enabled for usage in the instance. For more information see https://docs.aws.amazon.com/connect/latest/adminguide/multi-party-calls.html
multi_party_conference_enabled = config.get_bool("multiPartyConferenceEnabled")
if multi_party_conference_enabled is None:
    multi_party_conference_enabled = False
# A map of tags to assign to resources. These will be specific tags for this module, otherwise it is recommended to use `default_tags` in the AWS Provider
tags = config.get_object("tags")
if tags is None:
    tags = {}
instance_name = f"{name_prefix}-connect-{environment}"
# cloudwatch.tf
connect_instance_logs = []
for range in [{"value": i} for i in range(0, 1 if contact_flow_logs_enabled else 0)]:
    connect_instance_logs.append(aws.cloudwatch.LogGroup(f"connect_instance_logs-{range['value']}",
        name=f"/aws/connect/{instance_name}",
        tags=tags,
        retention_in_days=log_retention_days,
        kms_key_id=log_encryption_cmk if log_encryption_cmk != None else None))
# connect.tf
connect_instance = aws.connect.Instance("connect_instance",
    instance_alias=instance_name,
    identity_management_type=connect_identity_management_type,
    directory_id=connect_existing_directory_id if connect_identity_management_type == "EXISTING_DIRECTORY" else None,
    inbound_calls_enabled=inbound_calls_enabled,
    outbound_calls_enabled=outbound_calls_enabled,
    early_media_enabled=early_media_enabled,
    auto_resolve_best_voices_enabled=auto_resolve_best_voices_enabled,
    contact_flow_logs_enabled=contact_flow_logs_enabled,
    contact_lens_enabled=contact_lens_enabled,
    multi_party_conference_enabled=multi_party_conference_enabled)
s3_connect_name = std.lower_output(input=f"{name_prefix}-connect-content-bucket-{environment}").apply(lambda invoke: invoke.result)
create_new_bucket = True if existing_s3_bucket_name == None else False
# s3.tf
connect_content_bucket = []
for range in [{"value": i} for i in range(0, 1 if create_new_bucket else 0)]:
    connect_content_bucket.append(aws.s3.BucketV2(f"connect_content_bucket-{range['value']}",
        bucket=s3_connect_name,
        tags=tags))
s3_storage_bucket_name = existing_s3_bucket_name if existing_s3_bucket_name != None else connect_content_bucket[0].id
chat_transcripts = aws.connect.InstanceStorageConfig("chat_transcripts",
    instance_id=connect_instance.id,
    resource_type="CHAT_TRANSCRIPTS",
    storage_config=aws.connect.InstanceStorageConfigStorageConfigArgs(
        s3_config=aws.connect.InstanceStorageConfigStorageConfigS3ConfigArgs(
            encryption_config=single_or_none([{
                "encryptionType": "KMS",
                "keyId": s3_encryption_cmk,
            } for entry in [{"key": k, "value": v} for k, v in [1] if s3_encryption_cmk != None else []]]),
            bucket_name=s3_storage_bucket_name,
            bucket_prefix=f"connect/{instance_name}/ChatTranscripts",
        ),
        storage_type="S3",
    ))
call_recordings = aws.connect.InstanceStorageConfig("call_recordings",
    instance_id=connect_instance.id,
    resource_type="CALL_RECORDINGS",
    storage_config=aws.connect.InstanceStorageConfigStorageConfigArgs(
        s3_config=aws.connect.InstanceStorageConfigStorageConfigS3ConfigArgs(
            encryption_config=single_or_none([{
                "encryptionType": "KMS",
                "keyId": s3_encryption_cmk,
            } for entry in [{"key": k, "value": v} for k, v in [1] if s3_encryption_cmk != None else []]]),
            bucket_name=s3_storage_bucket_name,
            bucket_prefix=f"connect/{instance_name}/CallRecordings",
        ),
        storage_type="S3",
    ))
scheduled_reports = aws.connect.InstanceStorageConfig("scheduled_reports",
    instance_id=connect_instance.id,
    resource_type="SCHEDULED_REPORTS",
    storage_config=aws.connect.InstanceStorageConfigStorageConfigArgs(
        s3_config=aws.connect.InstanceStorageConfigStorageConfigS3ConfigArgs(
            encryption_config=single_or_none([{
                "encryptionType": "KMS",
                "keyId": s3_encryption_cmk,
            } for entry in [{"key": k, "value": v} for k, v in [1] if s3_encryption_cmk != None else []]]),
            bucket_name=s3_storage_bucket_name,
            bucket_prefix=f"connect/{instance_name}/Reports",
        ),
        storage_type="S3",
    ))
pulumi.export("connectInstanceAlias", connect_instance.instance_alias)
pulumi.export("connectInstanceArn", connect_instance.arn)
pulumi.export("connectInstanceId", connect_instance.id)
pulumi.export("connectServiceRole", connect_instance.service_role)
pulumi.export("connectInstanceStorageBucket", connect_content_bucket[0].id if create_new_bucket else None)
pulumi.export("connectCloudwatchLogGroupName", connect_instance_logs[0].name if contact_flow_logs_enabled else None)
content_bucket = []
for range in [{"value": i} for i in range(0, 1 if create_new_bucket else 0)]:
    content_bucket.append(aws.s3.BucketOwnershipControls(f"content_bucket-{range['value']}",
        bucket=connect_content_bucket[0].id,
        rule=aws.s3.BucketOwnershipControlsRuleArgs(
            object_ownership="ObjectWriter",
        )))
content_bucket_resource = []
for range in [{"value": i} for i in range(0, 1 if create_new_bucket else 0)]:
    content_bucket_resource.append(aws.s3.BucketAclV2(f"content_bucket-{range['value']}",
        bucket=connect_content_bucket[0].id,
        acl="private"))
content_bucket_resource2 = []
for range in [{"value": i} for i in range(0, 1 if create_new_bucket else 0)]:
    content_bucket_resource2.append(aws.s3.BucketServerSideEncryptionConfigurationV2(f"content_bucket-{range['value']}",
        bucket=connect_content_bucket[0].id,
        rules=[aws.s3.BucketServerSideEncryptionConfigurationV2RuleArgs(
            bucket_key_enabled=True,
            apply_server_side_encryption_by_default=aws.s3.BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs(
                kms_master_key_id=s3_encryption_cmk if s3_encryption_cmk != None else None,
                sse_algorithm="aws:kms" if s3_encryption_cmk != None else "AES256",
            ),
        )]))
content_bucket_resource3 = []
for range in [{"value": i} for i in range(0, 1 if create_new_bucket else 0)]:
    content_bucket_resource3.append(aws.s3.BucketVersioningV2(f"content_bucket-{range['value']}",
        bucket=connect_content_bucket[0].id,
        versioning_configuration=aws.s3.BucketVersioningV2VersioningConfigurationArgs(
            status="Suspended",
            mfa_delete="Disabled",
        )))
content_bucket_resource4 = []
for range in [{"value": i} for i in range(0, 1 if create_new_bucket else 0)]:
    content_bucket_resource4.append(aws.s3.BucketPublicAccessBlock(f"content_bucket-{range['value']}",
        bucket=connect_content_bucket[0].id,
        block_public_acls=True,
        block_public_policy=True,
        ignore_public_acls=True,
        restrict_public_buckets=True))
